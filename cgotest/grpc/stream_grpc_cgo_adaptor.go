// Code generated by protoc-gen-rpc-cgo-adaptor. DO NOT EDIT.
//
// source: stream.proto
// protocol: grpc

package cgotest_grpc

import (
	context "context"
	rpcruntime "github.com/ygrpc/rpccgo/rpcruntime"
)

// StreamService_UnaryCall_Grpc calls cgotest.StreamService.UnaryCall via grpc handler.
func StreamService_UnaryCall_Grpc(ctx context.Context, req *StreamRequest) (*StreamResponse, error) {
	h, ok := rpcruntime.LookupGrpcHandler("cgotest.StreamService")
	if !ok {
		return nil, rpcruntime.ErrServiceNotRegistered
	}
	svc, ok := h.(StreamServiceServer)
	if !ok {
		return nil, rpcruntime.ErrHandlerTypeMismatch
	}
	return svc.UnaryCall(ctx, req)
}

// StreamService_ClientStreamCall_Grpc client-streaming adaptor functions.
// These use a staged API: Start, Send, Finish.

// StreamService_ClientStreamCall_GrpcStart initializes a client-streaming call and returns a stream handle.
func StreamService_ClientStreamCall_GrpcStart(ctx context.Context) (uint64, error) {
	handle, childCtx, _ := rpcruntime.AllocateStreamHandle(ctx, rpcruntime.ProtocolGrpc)
	session := rpcruntime.GetStreamSession(rpcruntime.StreamHandle(handle))
	if session == nil {
		return 0, rpcruntime.ErrInvalidStreamHandle
	}

	h, ok := rpcruntime.LookupGrpcHandler("cgotest.StreamService")
	if !ok {
		return 0, rpcruntime.ErrServiceNotRegistered
	}
	svc, ok := h.(StreamServiceServer)
	if !ok {
		return 0, rpcruntime.ErrHandlerTypeMismatch
	}
	// Create adaptor stream and start handler goroutine
	adaptorStream := &streamService_ClientStreamCallServerAdaptor{session: session}
	session.SetHandlerState(adaptorStream)
	go func() {
		err := svc.ClientStreamCall(adaptorStream)
		rpcruntime.CompleteClientStream(handle, adaptorStream.lastResp, err)
	}()

	_ = childCtx // Used in goroutine
	return uint64(handle), nil
}

// StreamService_ClientStreamCall_GrpcSend sends a request message to the stream.
func StreamService_ClientStreamCall_GrpcSend(streamHandle uint64, req *StreamRequest) error {
	return rpcruntime.SendToStream(rpcruntime.StreamHandle(streamHandle), req)
}

// StreamService_ClientStreamCall_GrpcFinish closes the send-side and returns the final response.
func StreamService_ClientStreamCall_GrpcFinish(streamHandle uint64) (*StreamResponse, error) {
	resp, err := rpcruntime.FinishClientStream(rpcruntime.StreamHandle(streamHandle))
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, nil
	}
	return resp.(*StreamResponse), nil
}

// StreamService_ServerStreamCall_Grpc calls cgotest.StreamService.ServerStreamCall via the registered handler.
//
// This is a server-streaming method. Results are delivered via callbacks:
// - onRead is called for each response message; return false to stop receiving.
// - onDone is called exactly once when the stream ends or fails.
func StreamService_ServerStreamCall_Grpc(ctx context.Context, req *StreamRequest, onRead func(*StreamResponse) bool, onDone func(error)) error {
	h, ok := rpcruntime.LookupGrpcHandler("cgotest.StreamService")
	if !ok {
		onDone(rpcruntime.ErrServiceNotRegistered)
		return rpcruntime.ErrServiceNotRegistered
	}
	svc, ok := h.(StreamServiceServer)
	if !ok {
		onDone(rpcruntime.ErrHandlerTypeMismatch)
		return rpcruntime.ErrHandlerTypeMismatch
	}
	// Create adaptor stream with session
	handle, _, _ := rpcruntime.AllocateStreamHandle(ctx, rpcruntime.ProtocolGrpc)
	session := rpcruntime.GetStreamSession(handle)
	session.SetCallbacks(func(resp any) bool { return onRead(resp.(*StreamResponse)) }, onDone)
	adaptorStream := &streamService_ServerStreamCallServerAdaptor{session: session}
	err := svc.ServerStreamCall(req, adaptorStream)
	rpcruntime.FinishStreamHandle(handle)
	onDone(err)
	return err
}

// StreamService_BidiStreamCall_Grpc bidi-streaming adaptor functions.
// These use a combined staged + callback API: Start, Send, CloseSend + receive callbacks.

// StreamService_BidiStreamCall_GrpcStart initializes a bidi-streaming call and returns a stream handle.
// Provide onRead and onDone callbacks to receive response messages.
func StreamService_BidiStreamCall_GrpcStart(ctx context.Context, onRead func(*StreamResponse) bool, onDone func(error)) (uint64, error) {
	handle, childCtx, _ := rpcruntime.AllocateStreamHandle(ctx, rpcruntime.ProtocolGrpc)
	session := rpcruntime.GetStreamSession(rpcruntime.StreamHandle(handle))
	if session == nil {
		return 0, rpcruntime.ErrInvalidStreamHandle
	}
	session.SetCallbacks(func(resp any) bool { return onRead(resp.(*StreamResponse)) }, onDone)

	h, ok := rpcruntime.LookupGrpcHandler("cgotest.StreamService")
	if !ok {
		return 0, rpcruntime.ErrServiceNotRegistered
	}
	svc, ok := h.(StreamServiceServer)
	if !ok {
		return 0, rpcruntime.ErrHandlerTypeMismatch
	}
	// Create adaptor stream and start handler goroutine
	adaptorStream := &streamService_BidiStreamCallServerAdaptor{session: session}
	session.SetHandlerState(adaptorStream)
	go func() {
		err := svc.BidiStreamCall(adaptorStream)
		if cb := session.OnDone(); cb != nil {
			cb(err)
		}
		rpcruntime.FinishStreamHandle(handle)
	}()

	_ = childCtx // Used in goroutine
	return uint64(handle), nil
}

// StreamService_BidiStreamCall_GrpcSend sends a request message to the stream.
func StreamService_BidiStreamCall_GrpcSend(streamHandle uint64, req *StreamRequest) error {
	return rpcruntime.SendToStream(rpcruntime.StreamHandle(streamHandle), req)
}

// StreamService_BidiStreamCall_GrpcCloseSend closes the send-side of the stream.
func StreamService_BidiStreamCall_GrpcCloseSend(streamHandle uint64) error {
	return rpcruntime.CloseSendCh(rpcruntime.StreamHandle(streamHandle))
}
