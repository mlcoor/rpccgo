// Code generated by protoc-gen-rpc-cgo-adaptor. DO NOT EDIT.
//
// source: unary.proto
// protocols: grpc

package cgotest_grpc

import (
	context "context"
	rpcruntime "github.com/ygrpc/rpccgo/rpcruntime"
)

// TestService adaptor constants.
const (
	TestService_ServiceName         = "cgotest.TestService"
	TestService_Ping_FullMethod     = "/cgotest.TestService/Ping"
	TestService_PingOpt1_FullMethod = "/cgotest.TestService/PingOpt1"
	TestService_PingOpt2_FullMethod = "/cgotest.TestService/PingOpt2"
	TestService_NonFlat_FullMethod  = "/cgotest.TestService/NonFlat"
)

// TestService_Ping calls cgotest.TestService.Ping via the registered handler.
// Protocol selection: explicit via context, or fallback order: grpc
func TestService_Ping(ctx context.Context, req *PingRequest) (*PingResponse, error) {
	protocol, hasProtocol := rpcruntime.ProtocolFromContext(ctx)
	if hasProtocol {
		switch protocol {
		case rpcruntime.ProtocolGrpc:
			h, ok := rpcruntime.LookupGrpcHandler("cgotest.TestService")
			if !ok {
				return nil, rpcruntime.ErrServiceNotRegistered
			}
			svc, ok := h.(TestServiceServer)
			if !ok {
				return nil, rpcruntime.ErrHandlerTypeMismatch
			}
			return svc.Ping(ctx, req)
		default:
			return nil, rpcruntime.ErrUnknownProtocol
		}
	}

	// Fallback: try protocols in configured order.
	if h, ok := rpcruntime.LookupGrpcHandler("cgotest.TestService"); ok {
		if svc, ok := h.(TestServiceServer); ok {
			return svc.Ping(ctx, req)
		}
	}
	return nil, rpcruntime.ErrServiceNotRegistered
}

// TestService_PingOpt1 calls cgotest.TestService.PingOpt1 via the registered handler.
// Protocol selection: explicit via context, or fallback order: grpc
func TestService_PingOpt1(ctx context.Context, req *PingRequestOpt1) (*PingResponse, error) {
	protocol, hasProtocol := rpcruntime.ProtocolFromContext(ctx)
	if hasProtocol {
		switch protocol {
		case rpcruntime.ProtocolGrpc:
			h, ok := rpcruntime.LookupGrpcHandler("cgotest.TestService")
			if !ok {
				return nil, rpcruntime.ErrServiceNotRegistered
			}
			svc, ok := h.(TestServiceServer)
			if !ok {
				return nil, rpcruntime.ErrHandlerTypeMismatch
			}
			return svc.PingOpt1(ctx, req)
		default:
			return nil, rpcruntime.ErrUnknownProtocol
		}
	}

	// Fallback: try protocols in configured order.
	if h, ok := rpcruntime.LookupGrpcHandler("cgotest.TestService"); ok {
		if svc, ok := h.(TestServiceServer); ok {
			return svc.PingOpt1(ctx, req)
		}
	}
	return nil, rpcruntime.ErrServiceNotRegistered
}

// TestService_PingOpt2 calls cgotest.TestService.PingOpt2 via the registered handler.
// Protocol selection: explicit via context, or fallback order: grpc
func TestService_PingOpt2(ctx context.Context, req *PingRequestOpt2) (*PingResponse, error) {
	protocol, hasProtocol := rpcruntime.ProtocolFromContext(ctx)
	if hasProtocol {
		switch protocol {
		case rpcruntime.ProtocolGrpc:
			h, ok := rpcruntime.LookupGrpcHandler("cgotest.TestService")
			if !ok {
				return nil, rpcruntime.ErrServiceNotRegistered
			}
			svc, ok := h.(TestServiceServer)
			if !ok {
				return nil, rpcruntime.ErrHandlerTypeMismatch
			}
			return svc.PingOpt2(ctx, req)
		default:
			return nil, rpcruntime.ErrUnknownProtocol
		}
	}

	// Fallback: try protocols in configured order.
	if h, ok := rpcruntime.LookupGrpcHandler("cgotest.TestService"); ok {
		if svc, ok := h.(TestServiceServer); ok {
			return svc.PingOpt2(ctx, req)
		}
	}
	return nil, rpcruntime.ErrServiceNotRegistered
}

// TestService_NonFlat calls cgotest.TestService.NonFlat via the registered handler.
// Protocol selection: explicit via context, or fallback order: grpc
func TestService_NonFlat(ctx context.Context, req *NonFlatRequest) (*PingResponse, error) {
	protocol, hasProtocol := rpcruntime.ProtocolFromContext(ctx)
	if hasProtocol {
		switch protocol {
		case rpcruntime.ProtocolGrpc:
			h, ok := rpcruntime.LookupGrpcHandler("cgotest.TestService")
			if !ok {
				return nil, rpcruntime.ErrServiceNotRegistered
			}
			svc, ok := h.(TestServiceServer)
			if !ok {
				return nil, rpcruntime.ErrHandlerTypeMismatch
			}
			return svc.NonFlat(ctx, req)
		default:
			return nil, rpcruntime.ErrUnknownProtocol
		}
	}

	// Fallback: try protocols in configured order.
	if h, ok := rpcruntime.LookupGrpcHandler("cgotest.TestService"); ok {
		if svc, ok := h.(TestServiceServer); ok {
			return svc.NonFlat(ctx, req)
		}
	}
	return nil, rpcruntime.ErrServiceNotRegistered
}
