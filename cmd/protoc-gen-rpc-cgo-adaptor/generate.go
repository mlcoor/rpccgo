package main

import (
	"fmt"

	"google.golang.org/protobuf/compiler/protogen"
)

const (
	contextPackage = protogen.GoImportPath("context")
	rpcRuntimePkg  = protogen.GoImportPath("github.com/ygrpc/rpccgo/rpcruntime")
	grpcPackage    = protogen.GoImportPath("google.golang.org/grpc")
	connectPackage = protogen.GoImportPath("connectrpc.com/connect")
)

func generateFile(gen *protogen.Plugin, file *protogen.File, opts GeneratorOptions) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_cgo_adaptor.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-rpc-cgo-adaptor. DO NOT EDIT.")
	g.P("//")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	// Generate imports by referencing them in generated code.

	for _, service := range file.Services {
		generateService(g, file, service, opts)
	}

	return g
}

func generateService(
	g *protogen.GeneratedFile,
	file *protogen.File,
	service *protogen.Service,
	opts GeneratorOptions,
) {
	serviceName := string(service.Desc.FullName())

	// Generate constants for service name and full method names.
	g.P("// ", service.GoName, " adaptor constants.")
	g.P("const (")
	g.P("    ", service.GoName, "_ServiceName = ", fmt.Sprintf("%q", serviceName))
	for _, method := range service.Methods {
		fullMethod := fmt.Sprintf("/%s/%s", serviceName, method.Desc.Name())
		g.P("    ", service.GoName, "_", method.GoName, "_FullMethod = ", fmt.Sprintf("%q", fullMethod))
	}
	g.P(")")
	g.P()

	// Generate stream adaptor types for gRPC streaming methods.
	// Connect streaming uses rpcruntime helpers (NewClientStream, etc.) instead of adaptor types.
	if opts.Framework == FrameworkGrpc {
		for _, method := range service.Methods {
			isClientStreaming := method.Desc.IsStreamingClient()
			isServerStreaming := method.Desc.IsStreamingServer()
			if isClientStreaming || isServerStreaming {
				generateStreamAdaptorType(g, file, service, method, "grpc")
			}
		}
	}

	// Generate adaptor functions for each method.
	for _, method := range service.Methods {
		generateMethod(g, file, service, method, opts)
	}
}

func generateMethod(
	g *protogen.GeneratedFile,
	file *protogen.File,
	service *protogen.Service,
	method *protogen.Method,
	opts GeneratorOptions,
) {
	// Determine streaming type.
	isClientStreaming := method.Desc.IsStreamingClient()
	isServerStreaming := method.Desc.IsStreamingServer()

	if !isClientStreaming && !isServerStreaming {
		// Unary method.
		generateUnaryMethod(g, file, service, method, opts)
	} else if isClientStreaming && !isServerStreaming {
		// Client-streaming method.
		generateClientStreamingMethod(g, file, service, method, opts)
	} else if !isClientStreaming && isServerStreaming {
		// Server-streaming method.
		generateServerStreamingMethod(g, file, service, method, opts)
	} else {
		// Bidi-streaming method.
		generateBidiStreamingMethod(g, file, service, method, opts)
	}
}

func generateUnaryMethod(
	g *protogen.GeneratedFile,
	file *protogen.File,
	service *protogen.Service,
	method *protogen.Method,
	opts GeneratorOptions,
) {
	funcName := service.GoName + "_" + method.GoName
	reqType := g.QualifiedGoIdent(method.Input.GoIdent)
	respType := g.QualifiedGoIdent(method.Output.GoIdent)
	serviceName := string(service.Desc.FullName())

	g.P("// ", funcName, " calls ", method.Desc.FullName(), " via the registered handler.")
	g.P(
		"func ",
		funcName,
		"(ctx ",
		g.QualifiedGoIdent(contextPackage.Ident("Context")),
		", req *",
		reqType,
		") (*",
		respType,
		", error) {",
	)

	generateUnaryDispatch(g, service, method, serviceName, reqType, respType, opts)

	g.P("}")
	g.P()
}

func generateUnaryDispatch(
	g *protogen.GeneratedFile,
	service *protogen.Service,
	method *protogen.Method,
	serviceName, reqType, respType string,
	opts GeneratorOptions,
) {
	grpcServerIface := service.GoName + "Server"
	connectHandlerIface := service.GoName + "Handler"

	if opts.Framework == FrameworkGrpc {
		generateGrpcUnaryLookup(g, service, method, serviceName, grpcServerIface, "    ")
	} else {
		generateConnectUnaryLookup(g, service, method, serviceName, connectHandlerIface, "    ")
	}
}

func generateGrpcUnaryLookup(
	g *protogen.GeneratedFile,
	service *protogen.Service,
	method *protogen.Method,
	serviceName, ifaceName, indent string,
) {
	g.P(
		indent,
		"h, ok := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("LookupGrpcHandler")),
		"(",
		fmt.Sprintf("%q", serviceName),
		")",
	)
	g.P(indent, "if !ok {")
	g.P(indent, "    return nil, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrServiceNotRegistered")))
	g.P(indent, "}")
	g.P(indent, "svc, ok := h.(", ifaceName, ")")
	g.P(indent, "if !ok {")
	g.P(indent, "    return nil, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
	g.P(indent, "}")
	g.P(indent, "return svc.", method.GoName, "(ctx, req)")
}

func generateConnectUnaryLookup(
	g *protogen.GeneratedFile,
	service *protogen.Service,
	method *protogen.Method,
	serviceName, ifaceName, indent string,
) {
	g.P(
		indent,
		"h, ok := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("LookupConnectHandler")),
		"(",
		fmt.Sprintf("%q", serviceName),
		")",
	)
	g.P(indent, "if !ok {")
	g.P(indent, "    return nil, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrServiceNotRegistered")))
	g.P(indent, "}")
	g.P(indent, "svc, ok := h.(", ifaceName, ")")
	g.P(indent, "if !ok {")
	g.P(indent, "    return nil, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
	g.P(indent, "}")
	g.P(indent, "return svc.", method.GoName, "(ctx, req)")
}

func generateClientStreamingMethod(
	g *protogen.GeneratedFile,
	file *protogen.File,
	service *protogen.Service,
	method *protogen.Method,
	opts GeneratorOptions,
) {
	funcPrefix := service.GoName + "_" + method.GoName
	reqType := g.QualifiedGoIdent(method.Input.GoIdent)
	respType := g.QualifiedGoIdent(method.Output.GoIdent)
	serviceName := string(service.Desc.FullName())

	g.P("// ", funcPrefix, " client-streaming adaptor functions.")
	g.P("// These use a staged API: Start, Send, Finish.")
	g.P()

	// Determine protocol constant based on framework option
	var protocolConst string
	if opts.Framework == FrameworkGrpc {
		protocolConst = "ProtocolGrpc"
	} else {
		protocolConst = "ProtocolConnectRPC"
	}

	// Start function
	g.P("// ", funcPrefix, "Start initializes a client-streaming call and returns a stream handle.")
	g.P("func ", funcPrefix, "Start(ctx ", g.QualifiedGoIdent(contextPackage.Ident("Context")), ") (uint64, error) {")
	g.P(
		"    handle, childCtx, _ := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("AllocateStreamHandle")),
		"(ctx, ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident(protocolConst)),
		")",
	)
	g.P(
		"    session := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("GetStreamSession")),
		"(",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("StreamHandle")),
		"(handle))",
	)
	g.P("    if session == nil {")
	g.P("        return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrInvalidStreamHandle")))
	g.P("    }")
	g.P()

	if opts.Framework == FrameworkGrpc {
		generateClientStreamStartGrpc(g, service, method, serviceName, "    ")
	} else {
		generateClientStreamStartConnect(g, service, method, serviceName, "    ")
	}

	g.P()
	g.P("    _ = childCtx // Used in goroutine")
	g.P("    return uint64(handle), nil")
	g.P("}")
	g.P()

	// Send function
	g.P("// ", funcPrefix, "Send sends a request message to the stream.")
	g.P("func ", funcPrefix, "Send(streamHandle uint64, req *", reqType, ") error {")
	g.P(
		"    return ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("SendToStream")),
		"(",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("StreamHandle")),
		"(streamHandle), req)",
	)
	g.P("}")
	g.P()

	// Finish function
	g.P("// ", funcPrefix, "Finish closes the send-side and returns the final response.")
	g.P("func ", funcPrefix, "Finish(streamHandle uint64) (*", respType, ", error) {")
	g.P(
		"    resp, err := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("FinishClientStream")),
		"(",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("StreamHandle")),
		"(streamHandle))",
	)
	g.P("    if err != nil {")
	g.P("        return nil, err")
	g.P("    }")
	g.P("    if resp == nil {")
	g.P("        return nil, nil")
	g.P("    }")
	g.P("    return resp.(*", respType, "), nil")
	g.P("}")
	g.P()
}

func generateClientStreamStartGrpc(
	g *protogen.GeneratedFile,
	service *protogen.Service,
	method *protogen.Method,
	serviceName, indent string,
) {
	grpcServerIface := service.GoName + "Server"
	streamIface := service.GoName + "_" + method.GoName + "Server"

	g.P(
		indent,
		"h, ok := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("LookupGrpcHandler")),
		"(",
		fmt.Sprintf("%q", serviceName),
		")",
	)
	g.P(indent, "if !ok {")
	g.P(indent, "    return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrServiceNotRegistered")))
	g.P(indent, "}")
	g.P(indent, "svc, ok := h.(", grpcServerIface, ")")
	g.P(indent, "if !ok {")
	g.P(indent, "    return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
	g.P(indent, "}")
	g.P(indent, "// Create adaptor stream and start handler goroutine")
	g.P(indent, "adaptorStream := &", unexport(streamIface), "Adaptor{session: session}")
	g.P(indent, "session.SetHandlerState(adaptorStream)")
	g.P(indent, "go func() {")
	g.P(indent, "    err := svc.", method.GoName, "(adaptorStream)")
	g.P(
		indent,
		"    ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("CompleteClientStream")),
		"(handle, adaptorStream.lastResp, err)",
	)
	g.P(indent, "}()")
}

func generateClientStreamStartConnect(
	g *protogen.GeneratedFile,
	service *protogen.Service,
	method *protogen.Method,
	serviceName, indent string,
) {
	connectHandlerIface := service.GoName + "Handler"
	reqType := g.QualifiedGoIdent(method.Input.GoIdent)

	g.P(
		indent,
		"h, ok := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("LookupConnectHandler")),
		"(",
		fmt.Sprintf("%q", serviceName),
		")",
	)
	g.P(indent, "if !ok {")
	g.P(indent, "    return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrServiceNotRegistered")))
	g.P(indent, "}")
	g.P(indent, "svc, ok := h.(", connectHandlerIface, ")")
	g.P(indent, "if !ok {")
	g.P(indent, "    return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
	g.P(indent, "}")
	g.P(indent, "// Create Connect stream using rpcruntime helper")
	g.P(indent, "conn := ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("NewConnectStreamConn")), "(session)")
	g.P(
		indent,
		"connectStream := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("NewClientStream")),
		"[",
		reqType,
		"](conn)",
	)
	g.P(indent, "go func() {")
	g.P(indent, "    resp, err := svc.", method.GoName, "(childCtx, connectStream)")
	g.P(indent, "    ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("CompleteClientStream")), "(handle, resp, err)")
	g.P(indent, "}()")
}

func unexport(s string) string {
	if len(s) == 0 {
		return s
	}
	return string(s[0]+'a'-'A') + s[1:]
}

func generateServerStreamingMethod(
	g *protogen.GeneratedFile,
	file *protogen.File,
	service *protogen.Service,
	method *protogen.Method,
	opts GeneratorOptions,
) {
	// Server streaming uses callback API: onRead, onDone
	funcName := service.GoName + "_" + method.GoName
	reqType := g.QualifiedGoIdent(method.Input.GoIdent)
	respType := g.QualifiedGoIdent(method.Output.GoIdent)

	g.P("// ", funcName, " calls ", method.Desc.FullName(), " via the registered handler.")
	g.P("//")
	g.P("// This is a server-streaming method. Results are delivered via callbacks:")
	g.P("// - onRead is called for each response message; return false to stop receiving.")
	g.P("// - onDone is called exactly once when the stream ends or fails.")
	g.P(
		"func ",
		funcName,
		"(ctx ",
		g.QualifiedGoIdent(contextPackage.Ident("Context")),
		", req *",
		reqType,
		", onRead func(*",
		respType,
		") bool, onDone func(error)) error {",
	)

	serviceName := string(service.Desc.FullName())

	if opts.Framework == FrameworkGrpc {
		generateServerStreamGrpc(g, service, method, serviceName, respType, "    ")
	} else {
		generateServerStreamConnect(g, service, method, serviceName, respType, "    ")
	}

	g.P("}")
	g.P()
}

func generateServerStreamGrpc(
	g *protogen.GeneratedFile,
	service *protogen.Service,
	method *protogen.Method,
	serviceName, respType, indent string,
) {
	grpcServerIface := service.GoName + "Server"
	streamIface := service.GoName + "_" + method.GoName + "Server"

	g.P(
		indent,
		"h, ok := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("LookupGrpcHandler")),
		"(",
		fmt.Sprintf("%q", serviceName),
		")",
	)
	g.P(indent, "if !ok {")
	g.P(indent, "    onDone(", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrServiceNotRegistered")), ")")
	g.P(indent, "    return ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrServiceNotRegistered")))
	g.P(indent, "}")
	g.P(indent, "svc, ok := h.(", grpcServerIface, ")")
	g.P(indent, "if !ok {")
	g.P(indent, "    onDone(", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")), ")")
	g.P(indent, "    return ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
	g.P(indent, "}")
	g.P(indent, "// Create adaptor stream with session")
	g.P(
		indent,
		"handle, _, _ := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("AllocateStreamHandle")),
		"(ctx, ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("ProtocolGrpc")),
		")",
	)
	g.P(indent, "session := ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("GetStreamSession")), "(handle)")
	g.P(indent, "session.SetCallbacks(func(resp any) bool { return onRead(resp.(*", respType, ")) }, onDone)")
	g.P(indent, "adaptorStream := &", unexport(streamIface), "Adaptor{session: session}")
	g.P(indent, "err := svc.", method.GoName, "(req, adaptorStream)")
	g.P(indent, g.QualifiedGoIdent(rpcRuntimePkg.Ident("FinishStreamHandle")), "(handle)")
	g.P(indent, "onDone(err)")
	g.P(indent, "return err")
}

func generateServerStreamConnect(
	g *protogen.GeneratedFile,
	service *protogen.Service,
	method *protogen.Method,
	serviceName, respType, indent string,
) {
	connectHandlerIface := service.GoName + "Handler"

	g.P(
		indent,
		"h, ok := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("LookupConnectHandler")),
		"(",
		fmt.Sprintf("%q", serviceName),
		")",
	)
	g.P(indent, "if !ok {")
	g.P(indent, "    onDone(", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrServiceNotRegistered")), ")")
	g.P(indent, "    return ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrServiceNotRegistered")))
	g.P(indent, "}")
	g.P(indent, "svc, ok := h.(", connectHandlerIface, ")")
	g.P(indent, "if !ok {")
	g.P(indent, "    onDone(", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")), ")")
	g.P(indent, "    return ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
	g.P(indent, "}")
	g.P(indent, "// Create Connect stream using rpcruntime helper")
	g.P(
		indent,
		"handle, _, _ := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("AllocateStreamHandle")),
		"(ctx, ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("ProtocolConnectRPC")),
		")",
	)
	g.P(indent, "session := ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("GetStreamSession")), "(handle)")
	g.P(indent, "session.SetCallbacks(func(resp any) bool { return onRead(resp.(*", respType, ")) }, onDone)")
	g.P(indent, "conn := ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("NewConnectStreamConn")), "(session)")
	g.P(
		indent,
		"connectStream := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("NewServerStream")),
		"[",
		respType,
		"](conn)",
	)
	g.P(indent, "err := svc.", method.GoName, "(ctx, req, connectStream)")
	g.P(indent, g.QualifiedGoIdent(rpcRuntimePkg.Ident("FinishStreamHandle")), "(handle)")
	g.P(indent, "onDone(err)")
	g.P(indent, "return err")
}

func generateBidiStreamingMethod(
	g *protogen.GeneratedFile,
	file *protogen.File,
	service *protogen.Service,
	method *protogen.Method,
	opts GeneratorOptions,
) {
	funcPrefix := service.GoName + "_" + method.GoName
	reqType := g.QualifiedGoIdent(method.Input.GoIdent)
	respType := g.QualifiedGoIdent(method.Output.GoIdent)
	serviceName := string(service.Desc.FullName())

	g.P("// ", funcPrefix, " bidi-streaming adaptor functions.")
	g.P("// These use a combined staged + callback API: Start, Send, CloseSend + receive callbacks.")
	g.P()

	// Determine protocol constant based on framework option
	var protocolConst string
	if opts.Framework == FrameworkGrpc {
		protocolConst = "ProtocolGrpc"
	} else {
		protocolConst = "ProtocolConnectRPC"
	}

	// Start function
	g.P("// ", funcPrefix, "Start initializes a bidi-streaming call and returns a stream handle.")
	g.P("// Provide onRead and onDone callbacks to receive response messages.")
	g.P(
		"func ",
		funcPrefix,
		"Start(ctx ",
		g.QualifiedGoIdent(contextPackage.Ident("Context")),
		", onRead func(*",
		respType,
		") bool, onDone func(error)) (uint64, error) {",
	)

	g.P(
		"    handle, childCtx, _ := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("AllocateStreamHandle")),
		"(ctx, ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident(protocolConst)),
		")",
	)
	g.P(
		"    session := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("GetStreamSession")),
		"(",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("StreamHandle")),
		"(handle))",
	)
	g.P("    if session == nil {")
	g.P("        return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrInvalidStreamHandle")))
	g.P("    }")
	g.P("    session.SetCallbacks(func(resp any) bool { return onRead(resp.(*", respType, ")) }, onDone)")
	g.P()

	if opts.Framework == FrameworkGrpc {
		generateBidiStreamStartGrpc(g, service, method, serviceName, "    ")
	} else {
		generateBidiStreamStartConnect(g, service, method, serviceName, "    ")
	}

	g.P()
	g.P("    _ = childCtx // Used in goroutine")
	g.P("    return uint64(handle), nil")
	g.P("}")
	g.P()

	// Send function
	g.P("// ", funcPrefix, "Send sends a request message to the stream.")
	g.P("func ", funcPrefix, "Send(streamHandle uint64, req *", reqType, ") error {")
	g.P(
		"    return ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("SendToStream")),
		"(",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("StreamHandle")),
		"(streamHandle), req)",
	)
	g.P("}")
	g.P()

	// CloseSend function
	g.P("// ", funcPrefix, "CloseSend closes the send-side of the stream.")
	g.P("func ", funcPrefix, "CloseSend(streamHandle uint64) error {")
	g.P(
		"    return ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("CloseSendCh")),
		"(",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("StreamHandle")),
		"(streamHandle))",
	)
	g.P("}")
	g.P()
}

func generateBidiStreamStartGrpc(
	g *protogen.GeneratedFile,
	service *protogen.Service,
	method *protogen.Method,
	serviceName, indent string,
) {
	grpcServerIface := service.GoName + "Server"
	streamIface := service.GoName + "_" + method.GoName + "Server"

	g.P(
		indent,
		"h, ok := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("LookupGrpcHandler")),
		"(",
		fmt.Sprintf("%q", serviceName),
		")",
	)
	g.P(indent, "if !ok {")
	g.P(indent, "    return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrServiceNotRegistered")))
	g.P(indent, "}")
	g.P(indent, "svc, ok := h.(", grpcServerIface, ")")
	g.P(indent, "if !ok {")
	g.P(indent, "    return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
	g.P(indent, "}")
	g.P(indent, "// Create adaptor stream and start handler goroutine")
	g.P(indent, "adaptorStream := &", unexport(streamIface), "Adaptor{session: session}")
	g.P(indent, "session.SetHandlerState(adaptorStream)")
	g.P(indent, "go func() {")
	g.P(indent, "    err := svc.", method.GoName, "(adaptorStream)")
	g.P(indent, "    if cb := session.OnDone(); cb != nil {")
	g.P(indent, "        cb(err)")
	g.P(indent, "    }")
	g.P(indent, "    ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("FinishStreamHandle")), "(handle)")
	g.P(indent, "}()")
}

func generateBidiStreamStartConnect(
	g *protogen.GeneratedFile,
	service *protogen.Service,
	method *protogen.Method,
	serviceName, indent string,
) {
	connectHandlerIface := service.GoName + "Handler"
	reqType := g.QualifiedGoIdent(method.Input.GoIdent)
	respType := g.QualifiedGoIdent(method.Output.GoIdent)

	g.P(
		indent,
		"h, ok := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("LookupConnectHandler")),
		"(",
		fmt.Sprintf("%q", serviceName),
		")",
	)
	g.P(indent, "if !ok {")
	g.P(indent, "    return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrServiceNotRegistered")))
	g.P(indent, "}")
	g.P(indent, "svc, ok := h.(", connectHandlerIface, ")")
	g.P(indent, "if !ok {")
	g.P(indent, "    return 0, ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("ErrHandlerTypeMismatch")))
	g.P(indent, "}")
	g.P(indent, "// Create Connect bidi stream using rpcruntime helper")
	g.P(indent, "conn := ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("NewConnectStreamConn")), "(session)")
	g.P(
		indent,
		"connectStream := ",
		g.QualifiedGoIdent(rpcRuntimePkg.Ident("NewBidiStream")),
		"[",
		reqType,
		", ",
		respType,
		"](conn)",
	)
	g.P(indent, "session.SetHandlerState(connectStream)")
	g.P(indent, "go func() {")
	g.P(indent, "    err := svc.", method.GoName, "(childCtx, connectStream)")
	g.P(indent, "    if cb := session.OnDone(); cb != nil {")
	g.P(indent, "        cb(err)")
	g.P(indent, "    }")
	g.P(indent, "    ", g.QualifiedGoIdent(rpcRuntimePkg.Ident("FinishStreamHandle")), "(handle)")
	g.P(indent, "}()")
}

// generateStreamAdaptorType generates the adaptor struct that implements grpc's *_Server stream interface.
// This bridges the rpcruntime.streamSession with grpc's streaming expectations.
func generateStreamAdaptorType(
	g *protogen.GeneratedFile,
	file *protogen.File,
	service *protogen.Service,
	method *protogen.Method,
	framework string,
) {
	isClientStreaming := method.Desc.IsStreamingClient()
	isServerStreaming := method.Desc.IsStreamingServer()
	streamIface := service.GoName + "_" + method.GoName + "Server"
	adaptorName := unexport(streamIface) + "Adaptor"
	reqType := g.QualifiedGoIdent(method.Input.GoIdent)
	respType := g.QualifiedGoIdent(method.Output.GoIdent)
	sessionType := g.QualifiedGoIdent(rpcRuntimePkg.Ident("StreamSession"))

	g.P("// ", adaptorName, " adapts rpcruntime.StreamSession to ", streamIface, ".")
	g.P("type ", adaptorName, " struct {")
	g.P("    session ", sessionType)
	// For client-streaming, we need to store the response from SendAndClose.
	if isClientStreaming && !isServerStreaming {
		g.P("    lastResp *", respType)
	}
	g.P("}")
	g.P()

	// Implement grpc.ServerStream interface methods.
	g.P(
		"func (a *",
		adaptorName,
		") SetHeader(md ",
		g.QualifiedGoIdent(protogen.GoImportPath("google.golang.org/grpc/metadata").Ident("MD")),
		") error {",
	)
	g.P("    return nil // Not supported in CGO adaptor")
	g.P("}")
	g.P()

	g.P(
		"func (a *",
		adaptorName,
		") SendHeader(md ",
		g.QualifiedGoIdent(protogen.GoImportPath("google.golang.org/grpc/metadata").Ident("MD")),
		") error {",
	)
	g.P("    return nil // Not supported in CGO adaptor")
	g.P("}")
	g.P()

	g.P(
		"func (a *",
		adaptorName,
		") SetTrailer(md ",
		g.QualifiedGoIdent(protogen.GoImportPath("google.golang.org/grpc/metadata").Ident("MD")),
		") {",
	)
	g.P("    // Not supported in CGO adaptor")
	g.P("}")
	g.P()

	g.P("func (a *", adaptorName, ") Context() ", g.QualifiedGoIdent(contextPackage.Ident("Context")), " {")
	g.P("    return a.session.Context()")
	g.P("}")
	g.P()

	g.P("func (a *", adaptorName, ") SendMsg(m any) error {")
	g.P("    // Forward to onRead callback")
	g.P("    if cb := a.session.OnRead(); cb != nil {")
	g.P("        if !cb(m) {")
	g.P("            return ", g.QualifiedGoIdent(contextPackage.Ident("Canceled")))
	g.P("        }")
	g.P("    }")
	g.P("    return nil")
	g.P("}")
	g.P()

	g.P("func (a *", adaptorName, ") RecvMsg(m any) error {")
	g.P("    select {")
	g.P("    case msg, ok := <-a.session.SendCh():")
	g.P("        if !ok {")
	g.P("            return ", g.QualifiedGoIdent(protogen.GoImportPath("io").Ident("EOF")))
	g.P("        }")
	g.P("        // Copy message to m")
	g.P("        if src, ok := msg.(*", reqType, "); ok {")
	g.P("            if dst, ok := m.(*", reqType, "); ok {")
	g.P("                *dst = *src")
	g.P("            }")
	g.P("        }")
	g.P("        return nil")
	g.P("    case <-a.session.Context().Done():")
	g.P("        return a.session.Context().Err()")
	g.P("    }")
	g.P("}")
	g.P()

	// Generate streaming-specific methods based on streaming type.
	if isClientStreaming && !isServerStreaming {
		// Client-streaming: SendAndClose + Recv
		g.P("func (a *", adaptorName, ") SendAndClose(resp *", respType, ") error {")
		g.P("    // Store response for later retrieval")
		g.P("    a.lastResp = resp")
		g.P("    return nil")
		g.P("}")
		g.P()

		g.P("func (a *", adaptorName, ") Recv() (*", reqType, ", error) {")
		g.P("    msg := new(", reqType, ")")
		g.P("    if err := a.RecvMsg(msg); err != nil {")
		g.P("        return nil, err")
		g.P("    }")
		g.P("    return msg, nil")
		g.P("}")
		g.P()
	} else if !isClientStreaming && isServerStreaming {
		// Server-streaming: Send only
		g.P("func (a *", adaptorName, ") Send(resp *", respType, ") error {")
		g.P("    return a.SendMsg(resp)")
		g.P("}")
		g.P()
	} else {
		// Bidi-streaming: Send + Recv
		g.P("func (a *", adaptorName, ") Send(resp *", respType, ") error {")
		g.P("    return a.SendMsg(resp)")
		g.P("}")
		g.P()

		g.P("func (a *", adaptorName, ") Recv() (*", reqType, ", error) {")
		g.P("    msg := new(", reqType, ")")
		g.P("    if err := a.RecvMsg(msg); err != nil {")
		g.P("        return nil, err")
		g.P("    }")
		g.P("    return msg, nil")
		g.P("}")
		g.P()
	}

	// Add compile-time interface check.
	g.P("var _ ", streamIface, " = (*", adaptorName, ")(nil)")
	g.P()
}
