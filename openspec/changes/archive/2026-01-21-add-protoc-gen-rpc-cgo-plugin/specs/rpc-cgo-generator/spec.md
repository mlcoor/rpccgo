# rpc-cgo-generator Specification (Delta)

## ADDED Requirements

### Requirement: Provide protoc plugin `protoc-gen-rpc-cgo`
The system SHALL provide a protoc plugin named `protoc-gen-rpc-cgo`.
The plugin SHALL generate `package main` CGO-exported entrypoints that call the Go adaptor API generated by `protoc-gen-rpc-cgo-adaptor`.

#### Scenario: Plugin runs and emits package main files
- **GIVEN** a proto input containing at least one `service`
- **WHEN** `protoc-gen-rpc-cgo` generates code
- **THEN** it SHALL emit `package main` Go files into the `rpc-cgo_out` output directory
- **AND** it SHALL include a `main.go` containing `func main()`

#### Scenario: Output file name uses proto filename prefix
- **GIVEN** a proto file whose `GeneratedFilenamePrefix` is `foo`
- **WHEN** `protoc-gen-rpc-cgo` generates code for services in that file
- **THEN** it SHALL generate a file named `foo_cgo.go`

---

### Requirement: Use proto options to decide `free_strategy` and `native`
The plugin SHALL determine request free strategy and native generation using protobuf options defined on:
- `google.protobuf.FileOptions`
- `google.protobuf.MethodOptions`

Request free strategy options:
- `ygrpc_cgo_req_free_default` (FileOptions, int32): `0=none, 1=take_req, 2=both` (default: `0`)
- `ygrpc_cgo_req_free_method` (MethodOptions, int32): same mapping; if present, it overrides the file default

Native generation options:
- `ygrpc_cgo_native_default` (FileOptions, int32): `0=disable, 1=enable` (default: `0`)
- `ygrpc_cgo_native` (MethodOptions, int32): same mapping; if present, it overrides the file default

#### Scenario: Method option overrides file option
- **GIVEN** a proto file sets `ygrpc_cgo_native_default = 0`
- **AND** a method sets `ygrpc_cgo_native = 1`
- **WHEN** code is generated
- **THEN** the method SHALL be treated as native-enabled (subject to flat-message eligibility)

#### Scenario: Defaults applied when options absent
- **GIVEN** neither file nor method options are present
- **WHEN** code is generated
- **THEN** it SHALL behave as `free_strategy=none,native=false`

---

### Requirement: Stable C ABI naming conventions
The plugin SHALL generate exported C ABI functions whose symbol names follow the conventions:
- Unary Binary: `Ygrpc_{Service}_{Method}` and `Ygrpc_{Service}_{Method}_TakeReq`
- Unary Native: `Ygrpc_{Service}_{Method}_Native` and `Ygrpc_{Service}_{Method}_Native_TakeReq`
- Client-Stream: `Ygrpc_{Service}_{Method}Start` / `Send` / `Send_TakeReq` / `Finish`
- Client-Stream Native: `Ygrpc_{Service}_{Method}Start_Native` / `Send_Native` / `Send_Native_TakeReq` / `Finish_Native`
- Server-Stream: `Ygrpc_{Service}_{Method}` and `Ygrpc_{Service}_{Method}_TakeReq` (callback style)
- Server-Stream Native: `Ygrpc_{Service}_{Method}_Native` and `Ygrpc_{Service}_{Method}_Native_TakeReq`
- Bidi-Stream: `Ygrpc_{Service}_{Method}Start` / `Send` / `Send_TakeReq` / `CloseSend`
- Bidi-Stream Native: `Ygrpc_{Service}_{Method}Start_Native` / `Send_Native` / `Send_Native_TakeReq` / `CloseSend_Native`

The generated code SHOULD include comments describing each exported function, its parameters, and memory ownership rules.

#### Scenario: Unary naming derived from service+method
- **GIVEN** a service `S` with a unary method `M`
- **WHEN** code is generated
- **THEN** the exported symbols SHALL include `Ygrpc_S_M`

---

### Requirement: Return error id and use `Ygrpc_GetErrorMsg` for error retrieval
Each exported ABI function SHALL return `int`:
- return `0` on success
- return non-zero error id on failure

On failure, the implementation SHALL store an error message into the runtime error registry and return the corresponding id.
Error message retrieval SHALL be performed via `Ygrpc_GetErrorMsg` as defined by the `rpc-runtime` capability.

#### Scenario: Error id is returned and message retrievable
- **GIVEN** an exported ABI function encounters an error
- **WHEN** it returns to the C caller
- **THEN** it SHALL return a non-zero error id
- **AND** calling `Ygrpc_GetErrorMsg(error_id, ...)` SHALL be able to retrieve the error message (subject to TTL)

---

### Requirement: Binary variants use protobuf bytes and Go performs marshal/unmarshal
For Binary variants, the request and response payloads SHALL be encoded as protobuf wire-format bytes.

The generated CGO Go code SHALL:
- `proto.Unmarshal` the request bytes into the corresponding Go proto message struct before calling the adaptor API.
- `proto.Marshal` the adaptor response struct into bytes before returning to the C caller.

#### Scenario: Unary binary marshals request/response
- **GIVEN** a unary method `M(Req) returns (Resp)`
- **WHEN** the C caller invokes `Ygrpc_{Service}_{Method}` with protobuf-encoded request bytes
- **THEN** the generated code SHALL unmarshal into `Req` and call the adaptor
- **AND** on success it SHALL marshal `Resp` into bytes for the output buffer

---

### Requirement: Macro guards for shared C declarations
To avoid multiple definition conflicts, the generated code SHALL guard the `FreeFunc` typedef and the `Ygrpc_GetErrorMsg` declaration using `#ifndef` / `#define` / `#endif`.

#### Scenario: Multiple generated files compile together
- **GIVEN** multiple proto input files generate multiple `*_cgo.go` files
- **WHEN** the Go package is compiled
- **THEN** C preamble declarations SHALL not cause redefinition errors

---

### Requirement: Request free strategy controls TakeReq variants
After resolving `free_strategy` from proto options, the plugin SHALL generate TakeReq variants according to the following rules:
- If `free_strategy=none`: the plugin SHALL NOT generate `*_TakeReq` variants.
- If `free_strategy=take_req`: the plugin SHALL generate only `*_TakeReq` variants.
- If `free_strategy=both`: the plugin SHALL generate both standard and `*_TakeReq` variants.

For `*_TakeReq` variants, the ABI SHALL accept a `FreeFunc` argument to free the request buffer, and the exported function SHALL take ownership and invoke it exactly once after finishing using the request bytes.

#### Scenario: take_req emits TakeReq only
- **GIVEN** `free_strategy` resolves to `take_req`
- **WHEN** code is generated for a unary method
- **THEN** it SHALL generate `Ygrpc_{Service}_{Method}_TakeReq`
- **AND** it SHALL NOT generate `Ygrpc_{Service}_{Method}`

---

### Requirement: Native variants only for flat messages
If `native` resolves to `true`, the plugin SHALL generate native ABI variants only when the involved protobuf messages are flat:
- Supported field types: numeric scalars, `bool`, `string`, `bytes`
- Unsupported: `enum`, `optional`, `repeated`, `map`, `oneof`, nested `message`

If any message in the method (request/response or stream element) is not flat, the plugin SHALL NOT generate native variants for that method.

#### Scenario: Non-flat method has no native export
- **GIVEN** a method whose request message has a `repeated` field
- **WHEN** native-enabled generation runs
- **THEN** it SHALL NOT generate `_Native` exports for that method

---

### Requirement: Native and TakeReq can be combined
If native-enabled and `free_strategy` requires TakeReq, the plugin SHALL generate `_Native_TakeReq` variants.

#### Scenario: both emits Native and Native_TakeReq
- **GIVEN** a flat unary method and native resolves to `true` and `free_strategy=both`
- **WHEN** code is generated
- **THEN** it SHALL generate both `_Native` and `_Native_TakeReq` exports

---

### Requirement: Streaming exports exist and do not mix Native/Binary
For streaming methods, the plugin SHALL generate staged or callback exports per method type.
Native requests MUST pair with native responses; Binary requests MUST pair with binary responses (no mixing across a single RPC).

#### Scenario: Client-streaming uses Start/Send/Finish
- **GIVEN** a client-streaming method
- **WHEN** code is generated
- **THEN** it SHALL generate `Start`, `Send`, and `Finish` exports for that method

#### Scenario: Bidi-streaming combines Send and callbacks
- **GIVEN** a bidi-streaming method
- **WHEN** code is generated
- **THEN** it SHALL generate `Start`, `Send`, and `CloseSend` exports
- **AND** `Start` SHALL accept callbacks for streamed responses and completion

---

### Requirement: Server-streaming and Bidi-streaming callback signatures are explicit
For server-streaming and bidi-streaming methods, the generated Binary exports SHALL use callback functions to deliver streamed responses and completion.

For Binary response callbacks, the generated C ABI SHALL use the following callback signatures (exact parameter names may vary, but semantics MUST match):

Semantics:
- `onReadBytes` is invoked once per streamed response message.
- `resp_ptr/resp_len` is a protobuf-encoded message buffer.
- `resp_free` frees `resp_ptr` and MUST be callable exactly once per message.
- `onDone` is invoked exactly once when the stream ends; `error_id=0` indicates success, otherwise it is retrievable via `Ygrpc_GetErrorMsg`.
- `call_id` SHALL be passed to every callback invocation as the first parameter.
	- For server-streaming, `call_id` is supplied explicitly by the caller to the exported function.
	- For bidi-streaming, `call_id` is the `streamHandle` returned by `Start`.

For Native response callbacks, the generated ABI SHALL follow the same lifecycle semantics (onRead per message, onDone exactly once) and SHALL expose response fields using the native field mapping rules of this capability.

Native callback parameter rules:
- The onRead callback parameters (after `call_id`) SHALL list response fields ordered by protobuf field number ascending.
- Numeric scalars and `bool` SHALL be passed by value.
- Each `string` / `bytes` field SHALL be represented by `(const void* ptr, int len, FreeFunc free)`.
- If the response message is not flat, the plugin SHALL NOT generate any native streaming exports for that method.

#### Scenario: Server-streaming invokes onRead and onDone
- **GIVEN** a server-streaming method
- **WHEN** the exported function is invoked
- **THEN** it SHALL call `onReadBytes` for each response message
- **AND** it SHALL call `onDone` exactly once at completion

#### Scenario: Native streaming callback flattens fields
- **GIVEN** a server-streaming method whose response message is flat with fields `string result = 1` and `int32 sequence = 2`
- **WHEN** native exports are generated
- **THEN** the generated native onRead callback type SHALL accept `call_id` and then the flattened response fields in field-number order
