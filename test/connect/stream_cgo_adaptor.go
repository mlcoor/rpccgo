// Code generated by protoc-gen-rpc-cgo-adaptor. DO NOT EDIT.
//
// source: stream.proto

package cgotest

import (
	context "context"
	rpcruntime "github.com/ygrpc/rpccgo/rpcruntime"
)

// StreamService adaptor constants.
const (
	StreamService_ServiceName                 = "cgotest.StreamService"
	StreamService_UnaryCall_FullMethod        = "/cgotest.StreamService/UnaryCall"
	StreamService_ClientStreamCall_FullMethod = "/cgotest.StreamService/ClientStreamCall"
	StreamService_ServerStreamCall_FullMethod = "/cgotest.StreamService/ServerStreamCall"
	StreamService_BidiStreamCall_FullMethod   = "/cgotest.StreamService/BidiStreamCall"
)

// StreamService_UnaryCall calls cgotest.StreamService.UnaryCall via the registered handler.
func StreamService_UnaryCall(ctx context.Context, req *StreamRequest) (*StreamResponse, error) {
	h, ok := rpcruntime.LookupConnectHandler("cgotest.StreamService")
	if !ok {
		return nil, rpcruntime.ErrServiceNotRegistered
	}
	svc, ok := h.(StreamServiceHandler)
	if !ok {
		return nil, rpcruntime.ErrHandlerTypeMismatch
	}
	return svc.UnaryCall(ctx, req)
}

// StreamService_ClientStreamCall client-streaming adaptor functions.
// These use a staged API: Start, Send, Finish.

// StreamService_ClientStreamCallStart initializes a client-streaming call and returns a stream handle.
func StreamService_ClientStreamCallStart(ctx context.Context) (uint64, error) {
	handle, childCtx, _ := rpcruntime.AllocateStreamHandle(ctx, rpcruntime.ProtocolConnectRPC)
	session := rpcruntime.GetStreamSession(rpcruntime.StreamHandle(handle))
	if session == nil {
		return 0, rpcruntime.ErrInvalidStreamHandle
	}

	h, ok := rpcruntime.LookupConnectHandler("cgotest.StreamService")
	if !ok {
		return 0, rpcruntime.ErrServiceNotRegistered
	}
	svc, ok := h.(StreamServiceHandler)
	if !ok {
		return 0, rpcruntime.ErrHandlerTypeMismatch
	}
	// Create Connect stream using rpcruntime helper
	conn := rpcruntime.NewConnectStreamConn(session)
	connectStream := rpcruntime.NewClientStream[StreamRequest](conn)
	go func() {
		resp, err := svc.ClientStreamCall(childCtx, connectStream)
		rpcruntime.CompleteClientStream(handle, resp, err)
	}()

	_ = childCtx // Used in goroutine
	return uint64(handle), nil
}

// StreamService_ClientStreamCallSend sends a request message to the stream.
func StreamService_ClientStreamCallSend(streamHandle uint64, req *StreamRequest) error {
	return rpcruntime.SendToStream(rpcruntime.StreamHandle(streamHandle), req)
}

// StreamService_ClientStreamCallFinish closes the send-side and returns the final response.
func StreamService_ClientStreamCallFinish(streamHandle uint64) (*StreamResponse, error) {
	resp, err := rpcruntime.FinishClientStream(rpcruntime.StreamHandle(streamHandle))
	if err != nil {
		return nil, err
	}
	if resp == nil {
		return nil, nil
	}
	return resp.(*StreamResponse), nil
}

// StreamService_ServerStreamCall calls cgotest.StreamService.ServerStreamCall via the registered handler.
//
// This is a server-streaming method. Results are delivered via callbacks:
// - onRead is called for each response message; return false to stop receiving.
// - onDone is called exactly once when the stream ends or fails.
func StreamService_ServerStreamCall(ctx context.Context, req *StreamRequest, onRead func(*StreamResponse) bool, onDone func(error)) error {
	h, ok := rpcruntime.LookupConnectHandler("cgotest.StreamService")
	if !ok {
		onDone(rpcruntime.ErrServiceNotRegistered)
		return rpcruntime.ErrServiceNotRegistered
	}
	svc, ok := h.(StreamServiceHandler)
	if !ok {
		onDone(rpcruntime.ErrHandlerTypeMismatch)
		return rpcruntime.ErrHandlerTypeMismatch
	}
	// Create Connect stream using rpcruntime helper
	handle, _, _ := rpcruntime.AllocateStreamHandle(ctx, rpcruntime.ProtocolConnectRPC)
	session := rpcruntime.GetStreamSession(handle)
	session.SetCallbacks(func(resp any) bool { return onRead(resp.(*StreamResponse)) }, onDone)
	conn := rpcruntime.NewConnectStreamConn(session)
	connectStream := rpcruntime.NewServerStream[StreamResponse](conn)
	err := svc.ServerStreamCall(ctx, req, connectStream)
	rpcruntime.FinishStreamHandle(handle)
	onDone(err)
	return err
}

// StreamService_BidiStreamCall bidi-streaming adaptor functions.
// These use a combined staged + callback API: Start, Send, CloseSend + receive callbacks.

// StreamService_BidiStreamCallStart initializes a bidi-streaming call and returns a stream handle.
// Provide onRead and onDone callbacks to receive response messages.
func StreamService_BidiStreamCallStart(ctx context.Context, onRead func(*StreamResponse) bool, onDone func(error)) (uint64, error) {
	handle, childCtx, _ := rpcruntime.AllocateStreamHandle(ctx, rpcruntime.ProtocolConnectRPC)
	session := rpcruntime.GetStreamSession(rpcruntime.StreamHandle(handle))
	if session == nil {
		return 0, rpcruntime.ErrInvalidStreamHandle
	}
	session.SetCallbacks(func(resp any) bool { return onRead(resp.(*StreamResponse)) }, onDone)

	h, ok := rpcruntime.LookupConnectHandler("cgotest.StreamService")
	if !ok {
		return 0, rpcruntime.ErrServiceNotRegistered
	}
	svc, ok := h.(StreamServiceHandler)
	if !ok {
		return 0, rpcruntime.ErrHandlerTypeMismatch
	}
	// Create Connect bidi stream using rpcruntime helper
	conn := rpcruntime.NewConnectStreamConn(session)
	connectStream := rpcruntime.NewBidiStream[StreamRequest, StreamResponse](conn)
	session.SetHandlerState(connectStream)
	go func() {
		err := svc.BidiStreamCall(childCtx, connectStream)
		if cb := session.OnDone(); cb != nil {
			cb(err)
		}
		rpcruntime.FinishStreamHandle(handle)
	}()

	_ = childCtx // Used in goroutine
	return uint64(handle), nil
}

// StreamService_BidiStreamCallSend sends a request message to the stream.
func StreamService_BidiStreamCallSend(streamHandle uint64, req *StreamRequest) error {
	return rpcruntime.SendToStream(rpcruntime.StreamHandle(streamHandle), req)
}

// StreamService_BidiStreamCallCloseSend closes the send-side of the stream.
func StreamService_BidiStreamCallCloseSend(streamHandle uint64) error {
	return rpcruntime.CloseSendCh(rpcruntime.StreamHandle(streamHandle))
}
